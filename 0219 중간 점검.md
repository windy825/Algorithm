## 알고리즘

​       

- **무엇이 좋은 알고리즘인가?**
  - **정확성** 얼마나 정확하게 동작하는가
  - **작업량** 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - **메모리** 얼마나 적은 메모리를 사용하는가
  - **단순성** 얼마나 단순한가
  - **최적성** 더 이상 개선할 여지없이 최적화되었는가

​        

- **요소 수가 증가함에 따라** 각 시간복잡도의 알고리즘은 아래와 같은 연산 수를 보인다.

  ![제목 없음](https://user-images.githubusercontent.com/89068148/154791229-2e2fbb18-25e5-4ec1-8cdd-63ea1f7a99f8.png)

​       

- **배열의 필요성**
  - 여러 개의 변수가 필요할때, 일일이 다른 변수명을 이용하여 자료에 접근하는 것은 비효율적임
  - 배열 사용하면 하나의 선언을 통해 여러개의 변수를 선언할 수 있다.
  - 단순한 다수의 변수 선언에 유리함뿐만 아니라, 특정 작업 역시 원활하게 할 수 있다.

​       

​       

### 대표적인 정렬 방식

- `D2 숫자를 정렬하자` 이용해서 정렬법 적용연습 필수 :gun:

​          

- **버블 정렬 O(N^2)** : 교환 및 비교 방식 / 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

  - 코딩이 가장 쉽다.

  - ```python
    t = int(input())
    for idx in range(1, t+1):
        n = int(input())
        line = list(map(int,input().split()))
    
        for i in range(n-1):
            for j in range(n-i-1):
                if line[j] > line[j+1]:
                    line[j], line[j+1] = line[j+1], line[j]
        print(f'#{idx}',end=' ')
        print(*line)
    ```

    ​    

- **카운팅 정렬 O(N+k)** : 비교환 방식 / 정렬대상들의 개수 누적합으로 인덱스를 파악하여 위치 선정하는 방식

  - n이 비교적 작을때 가능하다 

  - 집합 내 가장 큰 정수를 알아야 한다 

  - 정수나 정수로 표현가능한 자료에만 가능

  - 연속된 수가 아니라면, 추가조건이 필요하다.( 개수 누적합할때 필요)

  - ```python
    t = int(input())
    for idx in range(1, t+1):
        n = int(input())
        line = list(map(int,input().split()))
        
        maxx = 0
        for i in line:
            if maxx < i:
                maxx = i
        
        cnt = [0]*(maxx+1)
        for j in line:
            cnt[j] +=1
        
        adding = 0
        for v in range(maxx+1):
            if cnt[v]:
                adding +=cnt[v]
                cnt[v] = adding
        
        answer = [0]*n
        for num in range(n-1,-1,-1):
            if cnt[line[num]]:
                cnt[line[num]] -=1
                answer[cnt[line[num]]] = line[num]
                
        print(f'#{idx}', end=' ')
        print(*answer)
    ```

    ​      

    

### 완전 검색

- **Exaustive Search, Brute-force, generate-and-test**
  - 일반적으로 경우의 수가 상대적으로 적을때 유용하다.
  - 수행속도는 느릴 수 있지만, 해답을 찾을 확률이 높다.

​        

- **순열**

  - **nPr** 서로 다른 n개 중 r개를 선택하는 순열 (순서O, 중복없이)

    ```python
    nPr = n * (n-1) * (n-2) * ... * (n-3) * (n-r+1)
    ```

  - **nPn = n!** 

    ```python
    nPn = n * (n-1) * (n-2) * ... * (n-3) * 2 * 1
    ```

    ​    

       

### 탐욕(Greedy) 알고리즘

- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에서의 최적해를 선택해 나가는 방식으로 

  최종적인 해답에 도달한다.

- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적해지만, 

  그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여 그것이 최적이라는 보장이 없다.

- 거스름돈 문제

  ```python
  exchange = int(input())
  answer = []
  
  for i in range(exchange//5, -1, -1):
      new = exchange - 5*i
      if new % 2 == 0:             # 중요한 부분 , 조건에 해당되지 않으면 다른 방법을 찾거나
          print(i + new//2)
          break
  else:
      print(-1)                    # 방법이 없음을 표현해야 한다.
  ```

  